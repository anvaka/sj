<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Imperative vs Declarative</title>
    <style type="text/css" media="all">
      .declarative, .imperative { margin: 0; padding: 0; width:580px}
      @media (min-width: 1200px) {
        .declarative, .imperative { width: 50%; float: left;}
      }
      .demoInfo { clear: both; }
      .sidenote { font-size: small;}
      body { font-family: helvetica; padding: 25px; }
      a { text-decoration: none; color: #2E8B57; }
      p { max-width: 580px; }
      code { margin: 8px;}
    </style>
    <link rel="stylesheet" href="../external/highlight/styles/default.css">
    <script src="../external/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <h2>Imperative vs Declarative drawing API</h2>
    <p>
    Many drawing libraries propose imperative API to render objects.
    E.g. <a href="http://d3js.org/">d3</a>, <a href="http://raphaeljs.com/">RaphaÃ«l</a>,
    <a href='http://fabricjs.com/'>fabric.js</a>, <a href="http://jonobr1.github.io/two.js/">two.js</a>,
    <a href='http://svgjs.com/'>svg.js</a>, <a href='http://snapsvg.io/'>snap.svg</a>
    they all offer some sort of javascript API to draw scene and append objects to it.
    </p>
    <p>If you programmed in both HTML and MFC you'll know how much
    easier it is to use declarative API to describe UI. Especially if you used
    <a href="http://angularjs.org/">angular.js</a> or <a href="http://emberjs.com/">ember.js</a>.</p>
    <p>
    In this post I wanted to explore available options for declarative programming of graphics.
    As a reference we'll take really good library <a href='http://jonobr1.github.io/two.js/'>two.js</a>.
    </p><p class='sidenote'>
    I am not trying to say imperative API is bad. It has a lot of value
    to offer. Sole purpose of this post is to check alternative options with declarative API
    </p>

    <h3>Basic usage</h3>
    <div class='demo'>

    <p class='demoInfo'>
      Let's compare basic example from two.js and pure SVG implementation.
    </p>
    <div class='imperative'>
      <h5>Imperative</h5>
      <pre><code>
// Make an instance of two and place it on the page.
var elem = document.getElementById('draw-shapes').children[0];
var params = { width: 280, height: 200 };
var two = new Two(params).appendTo(elem);

// two has convenience methods to create shapes.
var circle = two.makeCircle(72, 100, 50);
var rect = two.makeRectangle(150, 50, 100, 100);

// The object returned has many stylable properties:
circle.fill = '#FF8000';
circle.stroke = 'orangered'; // Accepts all valid css color
circle.linewidth = 5;

rect.fill = 'rgb(0, 200, 255)';
rect.opacity = 0.75;
rect.noStroke();

// Don't forget to tell two to render everything
// to the screen
two.update();
</code></pre>
    </div>
    <div class='declarative'>
      <h5>Declarative</h5>
<pre><code>
&lt;div id='#draw-shapes'&gt;
  &lt;svg width=&quot;280&quot; height=&quot;200&quot;&gt;
    &lt;circle cx=&quot;72&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;#FF8000&quot;
            stroke=&quot;orangered&quot; stroke-width=&quot;5&quot; /&gt;

    &lt;rect x=&quot;150&quot; y=&quot;50&quot; width=&quot;100&quot; height=&quot;100&quot;
          fill=&quot;rgb(0, 200, 255)&quot; opacity=&quot;0.75&quot;&gt;
  &lt;/svg&gt;
&lt;/div&gt;
</code></pre>
    </div>

    <p class='demoInfo'>
    As you can see declarative description in this case is much shorter and is
    very explicit. In fact you don't even need any library. Code works in
    your browser:
    </p>
    <div id='#draw-shapes'>
      <svg width="280" height="200">
        <circle cx="72" cy="100" r="50" fill="#FF8000" stroke="orangered" stroke-width="5" />
        <rect x="150" y="50" width="100" height="100" fill="rgb(0, 200, 255)" opacity="0.75">
      </svg>
    </div>
    </div>

    <div class='demo'>
      <h3>Groups and Animation</h3>

      <p class='demoInfo'>
      Many svg rendering libraries offer grouping of elements and some sort of
      animation support. SVG standard has <a href="http://www.w3.org/TR/SVG11/struct.html#Groups">group</a>
      element too. Animations are also <a href="http://www.w3.org/TR/SVG/animate.html">part of the standard</a>.
      </p>
      <div class='imperative'>
        <h5>Imperative</h5>
        <pre><code>
var elem = document.getElementById('draw-animation').children[0];
var two = new Two({ width: 280, height: 200 }).appendTo(elem);

var circle = two.makeCircle(-70, 0, 50);
var rect = two.makeRectangle(20, -50, 100, 100);
circle.fill = '#FF8000';
rect.fill = 'rgba(0, 200, 255, 0.75)';

var group = two.makeGroup(circle, rect);
group.translation.set(two.width / 2, two.height / 2);
group.scale = 0;
group.noStroke();

// Bind a function to scale and rotate the group
// to the animation loop.
two.bind('update', function(frameCount) {
  // This code is called everytime two.update() is called.
  // Effectively 60 times per second.
  if (group.scale &gt; 0.9999) {
    group.scale = group.rotation = 0;
  }
  var t = (1 - group.scale) * 0.125;
  group.scale += t;
  group.rotation += t * 4 * Math.PI;
}).play();  // Finally, start the animation loop
        </code></pre>
      </div>
      <div class='declarative'>
        <h5>Declarative</h5>
        <pre><code>
&lt;div id='#draw-shapes'&gt;
  &lt;svg width=&quot;280&quot; height=&quot;200&quot;&gt;
    &lt;g transform=&quot;translate(140, 100)&quot;&gt;
      &lt;g&gt;
        &lt;circle cx=&quot;-70&quot; cy=&quot;0&quot; r=&quot;50&quot; fill=&quot;#FF8000&quot;&gt;&lt;/circle&gt;
        &lt;rect x=&quot;20&quot; y=&quot;-50&quot; width=&quot;100&quot; height=&quot;100&quot;
              fill=&quot;rgb(0, 200, 255)&quot; opacity=&quot;0.75&quot;&gt;&lt;/rect&gt;

        &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;rotate&quot;
                    values=&quot;0 0 0;180 0 0;270 0 0;350 0 0; 360 0 0;&quot;
                    keyTimes=&quot;0;0.25;0.5;0.9; 1&quot; dur=&quot;1s&quot;
                    repeatCount='indefinite' /&gt;
        &lt;animateTransform attributeName='transform' type='scale'
                    keyTimes='0;0.3;0.75;1.0' values='0; 0.9;0.9;0.99;'
                    dur='1s' repeatCount='indefinite' additive='sum'/&gt;
      &lt;/g&gt;
    &lt;/g&gt;
  &lt;/svg&gt;
&lt;/div&gt;
        </code></pre>
      </div>
      <p class='demoInfo'>
      Declarative example works without any library in your browser:
      </p>
<div id='#draw-shapes'>
  <svg width="280" height="200">
    <g transform="translate(140, 100)">
      <g>
        <circle cx="-70" cy="0" r="50" fill="#FF8000"></circle>
        <rect x="20" y="-50" width="100" height="100"
              fill="rgb(0, 200, 255)" opacity="0.75"></rect>

        <animateTransform attributeName="transform" type="rotate"
                          values="0 0 0;180 0 0;270 0 0;350 0 0; 360 0 0;"
                          keyTimes="0;0.25;0.5;0.9; 1" dur="1s"
                          repeatCount='indefinite' />
        <animateTransform attributeName='transform' type='scale'
                          keyTimes='0;0.3;0.75;1.0' values='0; 0.9;0.9;0.99;'
                          dur='1s' repeatCount='indefinite' additive='sum'/>
      </g>
    </g>
  </svg>
</div>
      <p>
      It is more concise too. However it's arguably cleaner than imperative program,
      and it cheats by hardcoding values for transforms, and animations. Frankly,
      it was hard to create similar animation using animateTransform tag.
      </p>
    </div>
    <div class='demo'>
      <h3>When declarative is not enough?</h3>
      <p>
       By nature imperative drawing is very well suited for dynamic programs. When
       you don't know beforehand how many circles you might have on your screen.
      </p>

      <div class='imperative'>
        <h5>Imperative</h5>
        <pre><code>
var elem = document.getElementById('draw-shapes').children[0];
var params = { width: 280, height: 200 };
var two = new Two(params).appendTo(elem);

for (var i = 0; i &lt; 100; ++i) {
  two.makeCircle(i * 5, Math.random() * 100, 5);
}

two.update();
</code></pre>
      </div>
      <div class='declarative'>
        <h5>Declarative</h5>
<pre><code>
&lt;div id='#draw-shapes'&gt;
  &lt;svg width=&quot;280&quot; height=&quot;200&quot;&gt;
&lt;!-- ??? --&gt;
  &lt;/svg&gt;
&lt;/div&gt;
</code></pre>
      </div>
      <p class='demoInfo'>
      Declarative API by definition cannot contain control flow, but can we
      have best of two worlds? Of course we can! Angular.js uses bindings
      and custom directives to achieve it. If only we could use something like this:
      </p>
<div class='imperative'>
<pre><code>
&lt;svg width=&quot;280&quot; height=&quot;200&quot;&gt;
  &lt;g items-source=&quot;{circles}&quot;&gt;
    &lt;item-template&gt;
      &lt;circle cx=&quot;{x}&quot; cy=&quot;{y}&quot; r=&quot;5&quot; fill=&quot;#FF8000&quot;&gt;&lt;/circle&gt;
    &lt;/item-template&gt;
  &lt;/g&gt;
&lt;/svg&gt;
</code></pre>
</div>
      <p class='demoInfo'>
      Both <code>items-source</code> and <code>item-template</code> are not part of the
      SVG specification, but maybe a library could implement this?
      </p>
    </div>
  </body>
</html>
